1. 기존 방식(ConcurrentHashMap)의 문제점
   - 휘발성(Volatility): 서버 재시작이나 배포 시 메모리에 있던 모든 게임 데이터가 증발하여 '이어하기(Continue)'가 불가능함.
   - 상태 의존성(Stateful): 데이터가 특정 서버 인프라에 종속되어, 서버를 여러 대 띄우는 수평 확장(Scale-out) 시 유저 데이터 공유가 안 됨.
   - 자원 관리 부재: 게임 생성 시마다 데이터가 무한히 쌓여 메모리 누수(Memory Leak) 위험이 있으며, 종료된 게임을 삭제하는 별도의 클리너 로직이 부재함.
   - GC 부하: 수만 개의 SudokuGame 객체가 JVM Heap 영역을 점유하여 가비지 컬렉션 성능 저하 및 서버 멈춤(STW) 현상 초래 가능성.
2. Redis 도입을 결정한 핵심 근거 (Rationales)
    - 무상태 서버(Stateless) 달성: 서버는 로직(계산)만 담당하고 상태(기록)는 Redis가 관리하게 하여, 서버를 언제든 갈아끼우거나 늘릴 수 있는 유연한 구조 확보.
   - 강력한 영속성(Persistence): Redis의 AOF(Append Only File) 기능을 활용해, 인메모리의 속도를 유지하면서도 서버 장애 시 데이터 복구가 가능해져 '정식 이어하기' 보장.
   - 유저별 고정 슬롯 설계: userId를 키로 사용하여 '1유저 1게임' 원칙을 강제함. 새로운 게임 생성 시 기존 데이터를 자동으로 덮어쓰므로 무한 생성 버그를 인프라 단에서 원천 차단.
   - 성능과 영속성의 균형: 스도쿠는 입력 빈도가 낮으므로(턴제), 숫자 하나를 입력할 때마다 Redis에 즉시 저장(Write-Through)해도 성능 저하 없이 데이터 유실을 0에 가깝게 방지 가능.
   - 관심사의 분리: 진행 중인 'Hot Data'(Redis)와 종료된 'Cold Data'(DB)를 분리하여, DB는 최종 결과 기록이라는 본연의 역할에만 집중하게 함.
---
🧠 Sudoku 프로젝트: Redis 도입에 대한 고뇌와 결단
1. "서버가 죽으면 내 유저의 노력도 죽는가?" (영속성의 고민)
   - 고민: 처음엔 ConcurrentHashMap으로 간단히 끝내려 했습니다. 하지만 서버를 배포하거나 오류로 재시작하는 순간, 유저가 고심해서 채워넣은 스도쿠 판이 흔적도 없이 사라지는 게 용납되지 않았습니다.
   - 결단: "진정한 Continue(이어하기)를 보장하자." DB에 매번 넣자니 너무 무겁고, Redis를 쓰되 Redis AOF(Append Only File) 설정을 켜서 '인메모리의 속도'와 '로그 기반의 영속성' 사이의 최적점을 찾았습니다.
2. "서버는 왜 기억을 가져야 하는가?" (Stateless의 추구)
   - 고민: 서버가 게임 객체를 직접 들고 있으면(Stateful), 유저가 늘어날수록 서버의 메모리 부하(GC)가 커지고 서버 한 대로만 서비스해야 하는 '감옥'에 갇히게 된다는 걸 깨달았습니다.
   - 결단: "서버를 자유롭게 만들자." 서버에서 '기억(상태)'을 도려내어 Redis로 외주를 줬습니다. 이제 백엔드 서버는 언제든 죽어도 다른 서버가 즉시 대신할 수 있는 Stateless 아키텍처로 진화했습니다.
3. "숫자 하나 적을 때마다 저장하는 게 과한가?" (트레이드오프의 저울질)
   - 고민: 유저가 숫자 하나를 채울 때마다 저장 로직을 타는 게 자원 낭비 아닐까 걱정했습니다. 하지만 '지연 저장'을 선택하면 그 사이 서버가 터졌을 때 데이터 유실이 발생합니다.
   - 결단: "사용자 경험이 최우선이다." 스도쿠는 0.1초를 다투는 FPS가 아닙니다. Redis의 압도적인 쓰기 성능을 믿고, 숫자 하나하나를 즉시 저장(Write-Through)하여 유저가 언제 어디서든 마지막 상태 그대로 돌아올 수 있게 설계했습니다.
4. "유저당 게임은 왜 무한히 생성되는가?" (자원 격리와 관리)
   - 고민: 기존 로직에선 유저가 '새 게임'을 누를 때마다 이전 게임이 메모리에 좀비처럼 남는 구조였습니다. 언제 죽여야 할지도 모호했죠.
   - 결단: "1인 1슬롯 원칙." userId를 Redis 키로 직접 사용함으로써, 새 게임 생성 시 기존 게임은 자연스럽게 덮어씌워지게 했습니다. 별도의 삭제 로직 없이도 메모리 누수를 인프라 단에서 해결한 셈입니다.